generator client {
  provider = "prisma-client-js"
  output   = "../generated/client"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            Int                @id @default(autoincrement())
  firstname     String?
  lastname      String?
  email         String             @unique
  zapmail       String             @unique
  type          String
  verified      Boolean            @default(false)
  password      String?
  imageUrl      String?
  createdAt     DateTime           @default(now())
  updatedAt     DateTime           @updatedAt
  zap           Zap[]
  connections   UserConnection[]
  changeHistory ZapChangeHistory[] @relation("UserZapHistory")
  notes         ZapNote[]          @relation("userNotes")
  Folder        Folder[]           @relation("UserRootFolder")
  Trash         Zap[]              @relation("UserTrash")
}

model Zap {
  id            Int                @id @default(autoincrement())
  triggerId     String?
  name          String             @default("Untitled Zap")
  lastEdited    DateTime           @updatedAt
  createdAt     DateTime           @default(now())
  published     Boolean            @default(false)
  RecordId      String?            @unique
  userId        Int
  user          User               @relation(fields: [userId], references: [id])
  trigger       Trigger?
  actions       Action[]
  zapRuns       ZapRun[]
  records       Record[]
  record        Record?            @relation("ZapSingleRecord", fields: [RecordId], references: [id])
  changeHistory ZapChangeHistory[] @relation("zapHistory")
  notes         ZapNote[]          @relation("zapNotes")
  folderId      Int
  folder        Folder             @relation(fields: [folderId], references: [id])
  deleted       Boolean            @default(false)
  deletedAt     DateTime?
  deletedBy     Int?
  deletedByUser User?              @relation("UserTrash", fields: [deletedBy], references: [id])
}

model Folder {
  id        Int      @id @default(autoincrement())
  name      String
  userId    Int
  type      String   @default("root")
  user      User     @relation("UserRootFolder", fields: [userId], references: [id])
  parentId  Int?
  parent    Folder?  @relation("FolderHierarchy", fields: [parentId], references: [id])
  children  Folder[] @relation("FolderHierarchy")
  zaps      Zap[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Record {
  id              String   @id @default(uuid())
  type            String
  zap             Zap      @relation(fields: [zapId], references: [id])
  zapId           Int
  createdAt       DateTime @default(now())
  pulledAt        DateTime @updatedAt
  title           String
  JsonData        Json
  triggerOptionId String
  zapSingle       Zap?     @relation("ZapSingleRecord")
}

model Trigger {
  id             String            @id @default(uuid())
  zap            Zap               @relation(fields: [zapId], references: [id])
  zapId          Int               @unique
  optionId       String            @default("")
  optionType     String            @default("polling")
  published      Boolean           @default(false)
  configuration  Json
  lastPolledAt   DateTime?
  connectionId   String?
  userConnection UserConnection?   @relation(name: "TriggerToUserConnection", fields: [connectionId], references: [id])
  type           AvailableTriggers @relation(fields: [triggerId], references: [id])
  note           ZapNote?          @relation("triggerNote")
  triggerId      String
}

model UserConnection {
  id              String    @id @default(uuid())
  userId          Int
  appId           String
  identifier      String
  accessToken     String
  refreshToken    String?
  createdAt       DateTime  @default(now())
  expiredAt       DateTime
  User            User      @relation(fields: [userId], references: [id])
  lastRefreshedAt DateTime?
  trigger         Trigger[] @relation(name: "TriggerToUserConnection")
  action          Action[]  @relation(name: "ActionToUserConnection")
}

model AvailableTriggers {
  id          String    @id @default(uuid())
  name        String
  type        String    @default("trigger")
  serviceType String    @default("")
  appId       String?
  metadata    Json      @default("{}")
  imagePath   String    @default("")
  triggers    Trigger[]
}

model Action {
  id             String           @id @default(uuid())
  zapId          Int
  zap            Zap              @relation(fields: [zapId], references: [id])
  actionDetails  AvailableActions @relation(fields: [actionId], references: [id])
  success        Boolean?
  configuration  Json             @default("{}")
  optionId       String           @default("")
  actionId       String
  sortingOrder   Int              @default(0)
  connectionId   String?          @unique
  userConnection UserConnection?  @relation(name: "ActionToUserConnection", fields: [connectionId], references: [id])
  zapRunFailures ZapRun[]         @relation("ActionFailures")
  note           ZapNote?         @relation("actionNote")
  stepTests      ActionStepTest?  @relation("ActionStepTests")
}

model ActionStepTest {
  id        String   @id @default(uuid())
  dataOut   Json
  actionId  String   @unique
  action    Action   @relation(name: "ActionStepTests", fields: [actionId], references: [id])
  createdAt DateTime @default(now())
}

model AvailableActions {
  id          String   @id @default(uuid())
  name        String
  type        String   @default("action")
  serviceType String   @default("builtIn")
  appId       String?
  imagePath   String   @default("")
  actions     Action[]
  metadata    Json     @default("{}")
}

enum ZapRunStatus {
  PENDING
  RUNNING
  SUCCESS
  FAILED
}

enum ZapNoteType {
  ZAP_NOTE
  STEP_NOTE
}

enum ZapHistoryType {
  ZAP_CREATED
  ZAP_TURNED_OFF
  ZAP_DELETED
  OWNER_CHANGED
  ZAP_RESTORED
  ZAP_TURNED_ON
  VERSION_PUBLISHED
  APPROVAL_REQUEST_SENT
  APPROVAL_REQUEST_APPROVED
  APPROVAL_REQUEST_DENIED
  APPROVAL_REQUEST_CANCELLED
}

model ZapRun {
  id             String        @id @default(uuid())
  zapId          Int
  createdAt      DateTime      @default(now())
  completedAt    DateTime?
  status         ZapRunStatus  @default(PENDING) // unified run state
  failureReason  String?
  // Foreign key to Action for failed step
  failedActionId String?
  failedAction   Action?       @relation(name: "ActionFailures", fields: [failedActionId], references: [id])
  zap            Zap           @relation(fields: [zapId], references: [id])
  metaData       Json
  zapRunOutBox   ZapRunOutbox?
}

model ZapRunOutbox {
  id       String @id @default(uuid())
  zapRunId String @unique
  zapRun   ZapRun @relation(fields: [zapRunId], references: [id])
}

model ZapChangeHistory {
  id          String         @id @default(uuid())
  zapId       Int
  zap         Zap            @relation(name: "zapHistory", fields: [zapId], references: [id])
  type        ZapHistoryType // e.g., "TURNED_ON", "VERSION_PUBLISHED", "CREATED"
  message     String // human-readable: "Zap turned on"
  createdById Int
  createdBy   User           @relation(name: "UserZapHistory", fields: [createdById], references: [id])
  createdAt   DateTime       @default(now())
}

model ZapNote {
  id          String      @id @default(uuid())
  zapId       Int
  zap         Zap         @relation(name: "zapNotes", fields: [zapId], references: [id])
  triggerId   String?     @unique
  trigger     Trigger?    @relation(name: "triggerNote", fields: [triggerId], references: [id])
  stepId      String?     @unique()
  step        Action?     @relation(name: "actionNote", fields: [stepId], references: [id])
  type        ZapNoteType
  content     String
  createdById Int
  createdBy   User        @relation(name: "userNotes", fields: [createdById], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
